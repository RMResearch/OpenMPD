#ifndef _HELPER_METHODS
#define _HELPER_METHODS

#ifndef _USE_MATH_DEFINES
#define _USE_MATH_DEFINES
#endif

#ifndef LAPACK_COMPLEX_STRUCTURE
#define LAPACK_COMPLEX_STRUCTURE
#endif

#include <math.h>
#include <./lapacke.h>
#include <stdio.h>

static float rho_p() {
	return 25.0f; //density of particles 25Kg/m3
}

static float rho_a() {
	return 1.184f; //density of air 1.184Kg/m3
}

static float c_p() {
	return 2600.0f; //Speed of sound in particle
}

static float c_a() {
	return 346.0f; //Speed of sound in air
}

static float frequency() {
	return 40000.0f;
}

static float lambda() {
	static  float	_lambda = (c_a()/frequency());
	return _lambda;
}

static float K() {
	static  float	_K = (float)(2 * M_PI/lambda());
	return _K;
}

/*static float lambda() {
	static  float	_lambda = (float)(346.0f/40000);
	return _lambda;
}

static float K() {
	static  float	_K = (float)(2 * M_PI/(346.0f/40000));
	return _K;
}*/

static float omega() {
	static float _omega = (float)(2 * M_PI*frequency());
	return _omega;
}

static float particleRadius() {
	return 0.001f;//1mm
}

//Transducer radius
static float r0() {
	return 0.005f;//5mm radius
}
/**
	Computes the 3D position of a transducer, given its index in the board. 
	The board is assumed to rest at Z=0, and is composed of boardSize=16x32 number of transducers
	Boards are alocated "Top-Bottom" (i.e. All 256 elements from bottom board, followed by 256 elements of top n).
	The system of reference of the coordinate system is assumed to be at the centre of the bottom board. 
	The pitch (separation between transducers) is defined in variable pitch
	pos_out returns the resulting position
	NOTE: This is currently the preferred method. We will be changing GS_PAT to use this kind of scheme.

*/
static void computeTransducerPos_TopBottom(int t_index[2], float pitch, float pos_out[3]) {
	if (t_index[1] < 16) {
		pos_out[0] = (t_index[0] - 7.5f)*pitch;
		pos_out[1] = (7.5f - t_index[1] )*pitch;
		pos_out[2] = 0;
	}
	else {
		pos_out[0] = (t_index[0] - 7.5f)*pitch;
		pos_out[1] = (7.5f - (t_index[1]-16) )*pitch;
		pos_out[2] = 0.2388f;
	}
}


/**
	Computes the 3D position of a transducer, given its index in the board. 
	The board is assumed to rest at Z=0, and is composed of boardSize=32x16 number of transducers
	Boards are alocated "Side by Side" (i.e. first row of bottom board, followed by first row of top board).
	The system of reference of the coordinate system is assumed to be at the centre of the bottom board. 
	The pitch (separation between transducers) is defined in variable pitch
	pos_out returns the resulting position
	NOTE: This method is retained for backwards compatibility, as GS_PAT uses it to determine location of 
	transducers. We will be changing this in the future and only the version above will be used.
*/
static void computeTransducerPos_SideBySide(int t_index[2], float pitch, float pos_out[3]) {
	if (t_index[0] < 16) {
		//pos_out[0] = -(t_index[0] - 7.5f)*pitch;
		pos_out[0] = (t_index[0] - 7.5f)*pitch;
		pos_out[1] = (7.5f - t_index[1] )*pitch;
		pos_out[2] = 0;
	}
	else {
		//pos_out[0] = -((t_index[0] - 16) - 7.5f)*pitch;
		pos_out[0] = ((t_index[0] - 16) - 7.5f)*pitch;
		pos_out[1] = (7.5f - t_index[1] )*pitch;
		pos_out[2] = 0.2388f;
	}
}

/**
	Computes the amplitude of the field emitted by a transducer, according to a piston model
	It also returns the distance between the two points (this is simply convenient).
	- t_pos is the position of the transducer
	- point_pos is the position of the point where we need to know the amplitude.
*/
static void computeAmplitudeAndDistance(float t_pos[3], float point_pos[3], float* amplitude, float *distance, float P0=8.02f) {
	//a. Compute distance between point and transducer
	*distance = sqrtf((point_pos[0] - t_pos[0])*(point_pos[0] - t_pos[0]) + (point_pos[1] - t_pos[1])*(point_pos[1] - t_pos[1]) + (point_pos[2] - t_pos[2])*(point_pos[2] - t_pos[2]));
	//b. Compute directivity attenuation, based on angle between point and transducer normal (sin_alpha), and the directivity pattern (Bessel funciton)
	float sin_alpha = sqrtf((point_pos[0]- t_pos[0])*(point_pos[0] - t_pos[0]) + (point_pos[1] - t_pos[1])*(point_pos[1] - t_pos[1])) / (*distance);
	if (sin_alpha == 0)
		sin_alpha += 0.000000001f;
	*amplitude = (float)(2*_j1(K()*r0()*sin_alpha)*P0 / (K()*r0()*sin_alpha*(*distance)));
	if (*amplitude < 0)
		*amplitude *= -1;
}

static lapack_complex_float propagateFieldToPoint(float point[3], lapack_complex_float* singlePointField, const float* transducerPositions, int numTransducers, float P0=8.02f) {
	float Re = 0, Im = 0;
	for (int t = 0; t < numTransducers; t++) {
			const float* t_pos=&(transducerPositions[3*t]);
			//a. Compute field generated by transducer q(i,j) and the point p
			float distance, amplitude;
			computeAmplitudeAndDistance((float*)t_pos, point, &amplitude, &distance,P0);
			//c. Build complex number, representing the propagation of the field:
			float Re_prop = amplitude * cosf(K()*distance);
			float Im_prop = amplitude * sinf(K()*distance);
			if (isnan(Re_prop )|| isnan(Im_prop ))
				printf("WTF!\n");
			if (isnan(singlePointField[t].real) || isnan(singlePointField[t].imag))
				printf("WTF2; transducer %d\n",t);
			//d. Compute total field (multiply propagation with transducer state). 
			Re += (singlePointField[t].real*Re_prop - singlePointField[t].imag*Im_prop);
			Im += (singlePointField[t].real*Im_prop + singlePointField[t].imag*Re_prop);
		
	}
	lapack_complex_float result;
	result.real = Re; result.imag = Im;
	return result;
}



static lapack_complex_float propagateFieldToPoint(float point[3], lapack_complex_float* singlePointField, int boardSize[2], float pitch) {
	int w =  boardSize[0], h = boardSize[1];
	float Re = 0, Im = 0;
	for (int i = 0; i < w; i++) {
		for (int j = 0; j < h; j++) {
			int t_index[2]; t_index[0] = i; t_index[1] = j;
			float t_pos[3];
			//computeTransducerPos(t_index, boardSize, pitch, t_pos);
			computeTransducerPos_SideBySide(t_index, pitch, t_pos);
			//a. Compute field generated by transducer q(i,j) and the point p
			float distance, amplitude;
			computeAmplitudeAndDistance(t_pos, point, &amplitude, &distance);
			//c. Build complex number, representing the propagation of the field:
			float Re_prop = amplitude * cosf(K()*distance);
			float Im_prop = amplitude * sinf(K()*distance);
			//d. Compute total field (multiply propagation with transducer state). 
			Re += (singlePointField[i + j*w].real*Re_prop - singlePointField[i + j*w].imag*Im_prop);
			Im += (singlePointField[i + j*w].real*Im_prop + singlePointField[i + j*w].imag*Re_prop);
			/* //DEBUG (CHECK AMPLITUDE<1)
			float amplitudeTransducer = sqrtf(singlePointField[i + j*w].real*singlePointField[i + j*w].real + singlePointField[i + j*w].imag*singlePointField[i + j*w].imag);
			if (amplitudeTransducer >= 1)
				printf("Power violation!");*/

		}
	}
	lapack_complex_float result;
	result.real = Re; result.imag = Im;
	return result;
}


static lapack_complex_float propagateFieldToPointFromPhases(float point[3], float* singlePointField_Phases, int boardSize[2], float pitch) {
	int w = boardSize[0], h = boardSize[1];
	float Re = 0, Im = 0;
	for (int i = 0; i < w; i++) {
		for (int j = 0; j < h; j++) {
			int t_index[2]; t_index[0] = i; t_index[1] = j;
			float t_pos[3];
			//computeTransducerPos(t_index, boardSize, pitch, t_pos);
			computeTransducerPos_SideBySide(t_index, pitch, t_pos);
			//a. Compute field generated by transducer q(i,j) and the point p
			float distance, amplitude;
			computeAmplitudeAndDistance(t_pos, point, &amplitude, &distance);
			//c. Build complex number, representing the propagation of the field:
			float Re_prop = amplitude * cosf(K()*distance);
			float Im_prop = amplitude * sinf(K()*distance);
			//d. Compute total field (multiply propagation with transducer state). 
			Re += cosf(singlePointField_Phases[i + j*w])*Re_prop - sinf(singlePointField_Phases[i + j*w])*Im_prop;
			Im += cosf(singlePointField_Phases[i + j*w])*Im_prop + sinf(singlePointField_Phases[i + j*w])*Re_prop;

		}
	}
	lapack_complex_float result;
	result.real = Re; result.imag = Im;
	return result;
}
#endif